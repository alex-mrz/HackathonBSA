import { G1Element } from './bls12381.js';
import type { KeyServer } from './key-server.js';
import type { SessionKey } from './session-key.js';
import type { EncryptedObject } from './types.js';
/**
 * A class to cache user secret keys after they have been fetched from key servers.
 */
export declare class KeyStore {
    private readonly keys_map;
    constructor();
    private createMapKey;
    /** @internal */
    addKey(fullId: Uint8Array, objectId: Uint8Array, key: G1Element): void;
    /**
     * Get a key from this KeyStore or undefined if the key is not found.
     *
     * @param fullId The full ID used to derive the key.
     * @param objectId The object ID of the key server holding the key.
     */
    private getKey;
    /**
     * Check if the key store has a key for the given full ID and object ID.
     *
     * @param fullId The full ID used to derive the key.
     * @param objectId The object ID of the key server holding the key.
     */
    private hasKey;
    /**
     * Look up URLs of key servers and fetch key from servers with request signature,
     * cert and ephPk, then updates the caching keys_map.
     */
    fetchKeys({ keyServers, threshold: _threshold, packageId, ids, txBytes, sessionKey, }: {
        keyServers: KeyServer[];
        threshold: number;
        packageId: Uint8Array;
        ids: Uint8Array[];
        txBytes: Uint8Array;
        sessionKey: SessionKey;
    }): Promise<void>;
    /**
     * Decrypt the given encrypted bytes with the given cached secret keys for the full ID.
     * It's assumed that fetchKeys has been called to fetch the secret keys for enough key servers
     * otherwise, this will throw an error.
     *
     * @param encryptedObject - EncryptedObject.
     * @returns - The decrypted plaintext corresponding to ciphertext.
     */
    decrypt(encryptedObject: typeof EncryptedObject.$inferType): Promise<Uint8Array>;
}
