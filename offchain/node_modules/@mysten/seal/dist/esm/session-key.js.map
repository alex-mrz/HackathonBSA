{
  "version": 3,
  "sources": ["../../src/session-key.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toBase64, toHex } from '@mysten/bcs';\nimport { bcs } from '@mysten/sui/bcs';\nimport { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';\n\nimport { generateSecretKey, toPublicKey, toVerificationKey } from './elgamal.js';\n\nexport const RequestFormat = bcs.struct('RequestFormat', {\n\tptb: bcs.vector(bcs.U8),\n\tenc_key: bcs.vector(bcs.U8),\n\tenc_verification_key: bcs.vector(bcs.U8),\n});\n\nexport type Certificate = {\n\tsession_vk: string;\n\tcreation_time: number;\n\tttl_min: number;\n\tsignature: string;\n};\n\nexport class SessionKey {\n\tprivate packageId: Uint8Array;\n\tprivate creationTime: number;\n\tprivate ttlMin: number;\n\tprivate session_key: Ed25519Keypair;\n\tprivate personalMessageSignature: string;\n\n\tconstructor(packageId: Uint8Array, ttlMin: number) {\n\t\tthis.packageId = packageId;\n\t\tthis.creationTime = Date.now();\n\t\tthis.ttlMin = ttlMin;\n\t\tthis.session_key = Ed25519Keypair.generate();\n\t\tthis.personalMessageSignature = '';\n\t}\n\n\tgetPersonalMessage(): Uint8Array {\n\t\t// TODO: decide if we want 0x on the server end\n\t\tconst message = `Requesting access to keys of package ${toHex(this.packageId)} for ${this.ttlMin} mins, session key ${toBase64(this.session_key.getPublicKey().toRawBytes())}, created at ${this.creationTime}`;\n\t\treturn new TextEncoder().encode(message);\n\t}\n\n\tsetPersonalMessageSignature(personalMessageSignature: string) {\n\t\tthis.personalMessageSignature = personalMessageSignature;\n\t}\n\n\tgetCertificate(): Certificate {\n\t\tif (this.personalMessageSignature === '') {\n\t\t\tthrow new Error('Personal message signature is not set');\n\t\t}\n\t\treturn {\n\t\t\tsession_vk: toBase64(this.session_key.getPublicKey().toRawBytes()),\n\t\t\tcreation_time: this.creationTime,\n\t\t\tttl_min: this.ttlMin,\n\t\t\tsignature: this.personalMessageSignature,\n\t\t};\n\t}\n\n\tasync createRequestParams(\n\t\ttxBytes: Uint8Array,\n\t): Promise<{ decryption_key: Uint8Array; request_signature: string }> {\n\t\tlet eg_sk = generateSecretKey();\n\t\tconst msgToSign = RequestFormat.serialize({\n\t\t\tptb: txBytes.slice(1),\n\t\t\tenc_key: toPublicKey(eg_sk),\n\t\t\tenc_verification_key: toVerificationKey(eg_sk),\n\t\t}).toBytes();\n\t\treturn {\n\t\t\tdecryption_key: eg_sk,\n\t\t\trequest_signature: toBase64(await this.session_key.sign(msgToSign)),\n\t\t};\n\t}\n}\n"],
  "mappings": "AAGA,SAAS,UAAU,aAAa;AAChC,SAAS,WAAW;AACpB,SAAS,sBAAsB;AAE/B,SAAS,mBAAmB,aAAa,yBAAyB;AAE3D,MAAM,gBAAgB,IAAI,OAAO,iBAAiB;AAAA,EACxD,KAAK,IAAI,OAAO,IAAI,EAAE;AAAA,EACtB,SAAS,IAAI,OAAO,IAAI,EAAE;AAAA,EAC1B,sBAAsB,IAAI,OAAO,IAAI,EAAE;AACxC,CAAC;AASM,MAAM,WAAW;AAAA,EAOvB,YAAY,WAAuB,QAAgB;AAClD,SAAK,YAAY;AACjB,SAAK,eAAe,KAAK,IAAI;AAC7B,SAAK,SAAS;AACd,SAAK,cAAc,eAAe,SAAS;AAC3C,SAAK,2BAA2B;AAAA,EACjC;AAAA,EAEA,qBAAiC;AAEhC,UAAM,UAAU,wCAAwC,MAAM,KAAK,SAAS,CAAC,QAAQ,KAAK,MAAM,sBAAsB,SAAS,KAAK,YAAY,aAAa,EAAE,WAAW,CAAC,CAAC,gBAAgB,KAAK,YAAY;AAC7M,WAAO,IAAI,YAAY,EAAE,OAAO,OAAO;AAAA,EACxC;AAAA,EAEA,4BAA4B,0BAAkC;AAC7D,SAAK,2BAA2B;AAAA,EACjC;AAAA,EAEA,iBAA8B;AAC7B,QAAI,KAAK,6BAA6B,IAAI;AACzC,YAAM,IAAI,MAAM,uCAAuC;AAAA,IACxD;AACA,WAAO;AAAA,MACN,YAAY,SAAS,KAAK,YAAY,aAAa,EAAE,WAAW,CAAC;AAAA,MACjE,eAAe,KAAK;AAAA,MACpB,SAAS,KAAK;AAAA,MACd,WAAW,KAAK;AAAA,IACjB;AAAA,EACD;AAAA,EAEA,MAAM,oBACL,SACqE;AACrE,QAAI,QAAQ,kBAAkB;AAC9B,UAAM,YAAY,cAAc,UAAU;AAAA,MACzC,KAAK,QAAQ,MAAM,CAAC;AAAA,MACpB,SAAS,YAAY,KAAK;AAAA,MAC1B,sBAAsB,kBAAkB,KAAK;AAAA,IAC9C,CAAC,EAAE,QAAQ;AACX,WAAO;AAAA,MACN,gBAAgB;AAAA,MAChB,mBAAmB,SAAS,MAAM,KAAK,YAAY,KAAK,SAAS,CAAC;AAAA,IACnE;AAAA,EACD;AACD;",
  "names": []
}
