import { fromBase64, fromHex, toHex } from "@mysten/bcs";
import { bcs } from "@mysten/sui/bcs";
import { bls12_381 } from "@noble/curves/bls12-381";
import { DST_POP } from "./ibe.js";
var KeyServerType = /* @__PURE__ */ ((KeyServerType2) => {
  KeyServerType2[KeyServerType2["BonehFranklinBLS12381"] = 0] = "BonehFranklinBLS12381";
  return KeyServerType2;
})(KeyServerType || {});
const KeyServerMove = bcs.struct("KeyServer", {
  id: bcs.Address,
  name: bcs.string(),
  url: bcs.string(),
  key_type: bcs.u8(),
  pk: bcs.vector(bcs.u8())
});
function getAllowlistedKeyServers(network) {
  if (network === "testnet") {
    return [
      fromHex("0xb35a7228d8cf224ad1e828c0217c95a5153bafc2906d6f9c178197dce26fbcf8"),
      fromHex("0x2d6cde8a9d9a65bde3b0a346566945a63b4bfb70e9a06c41bdb70807e2502b06")
    ];
  } else {
    throw new Error("Network not supported");
  }
}
async function retrieveKeyServers({
  objectIds,
  client
}) {
  return await Promise.all(
    objectIds.map(async (objectId) => {
      const res = await client.getObject({
        id: toHex(objectId),
        options: {
          showBcs: true
        }
      });
      if (!res || res.error || !res.data) {
        throw new Error(`KeyServer ${objectId} not found; ${res.error}`);
      }
      if (!res.data.bcs || !("bcsBytes" in res.data.bcs)) {
        throw new Error(`Invalid KeyServer query: ${objectId}, expected object, got package`);
      }
      let ks = KeyServerMove.parse(fromBase64(res.data.bcs.bcsBytes));
      if (ks.key_type !== 0) {
        throw new Error("Unsupported key type");
      }
      return {
        objectId,
        name: ks.name,
        url: ks.url,
        keyType: 0 /* BonehFranklinBLS12381 */,
        pk: new Uint8Array(ks.pk)
      };
    })
  );
}
async function verifyKeyServer(server) {
  const response = await fetch(server.url + "/v1/service", {
    method: "GET",
    headers: {
      "Content-Type": "application/json"
    }
  });
  const serviceResponse = await response.json();
  if (serviceResponse.service_id !== server.objectId) {
    return false;
  }
  const fullMsg = new Uint8Array([...DST_POP, ...server.pk, ...server.objectId]);
  return bls12_381.verifyShortSignature(fromBase64(serviceResponse.pop), fullMsg, server.pk);
}
export {
  KeyServerType,
  getAllowlistedKeyServers,
  retrieveKeyServers,
  verifyKeyServer
};
//# sourceMappingURL=key-server.js.map
