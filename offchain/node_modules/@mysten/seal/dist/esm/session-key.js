import { toBase64, toHex } from "@mysten/bcs";
import { bcs } from "@mysten/sui/bcs";
import { Ed25519Keypair } from "@mysten/sui/keypairs/ed25519";
import { generateSecretKey, toPublicKey, toVerificationKey } from "./elgamal.js";
const RequestFormat = bcs.struct("RequestFormat", {
  ptb: bcs.vector(bcs.U8),
  enc_key: bcs.vector(bcs.U8),
  enc_verification_key: bcs.vector(bcs.U8)
});
class SessionKey {
  constructor(packageId, ttlMin) {
    this.packageId = packageId;
    this.creationTime = Date.now();
    this.ttlMin = ttlMin;
    this.session_key = Ed25519Keypair.generate();
    this.personalMessageSignature = "";
  }
  getPersonalMessage() {
    const message = `Requesting access to keys of package ${toHex(this.packageId)} for ${this.ttlMin} mins, session key ${toBase64(this.session_key.getPublicKey().toRawBytes())}, created at ${this.creationTime}`;
    return new TextEncoder().encode(message);
  }
  setPersonalMessageSignature(personalMessageSignature) {
    this.personalMessageSignature = personalMessageSignature;
  }
  getCertificate() {
    if (this.personalMessageSignature === "") {
      throw new Error("Personal message signature is not set");
    }
    return {
      session_vk: toBase64(this.session_key.getPublicKey().toRawBytes()),
      creation_time: this.creationTime,
      ttl_min: this.ttlMin,
      signature: this.personalMessageSignature
    };
  }
  async createRequestParams(txBytes) {
    let eg_sk = generateSecretKey();
    const msgToSign = RequestFormat.serialize({
      ptb: txBytes.slice(1),
      enc_key: toPublicKey(eg_sk),
      enc_verification_key: toVerificationKey(eg_sk)
    }).toBytes();
    return {
      decryption_key: eg_sk,
      request_signature: toBase64(await this.session_key.sign(msgToSign))
    };
  }
}
export {
  RequestFormat,
  SessionKey
};
//# sourceMappingURL=session-key.js.map
