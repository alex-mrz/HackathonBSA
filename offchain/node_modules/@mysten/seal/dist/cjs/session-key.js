"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var session_key_exports = {};
__export(session_key_exports, {
  RequestFormat: () => RequestFormat,
  SessionKey: () => SessionKey
});
module.exports = __toCommonJS(session_key_exports);
var import_bcs = require("@mysten/bcs");
var import_bcs2 = require("@mysten/sui/bcs");
var import_ed25519 = require("@mysten/sui/keypairs/ed25519");
var import_elgamal = require("./elgamal.js");
const RequestFormat = import_bcs2.bcs.struct("RequestFormat", {
  ptb: import_bcs2.bcs.vector(import_bcs2.bcs.U8),
  enc_key: import_bcs2.bcs.vector(import_bcs2.bcs.U8),
  enc_verification_key: import_bcs2.bcs.vector(import_bcs2.bcs.U8)
});
class SessionKey {
  constructor(packageId, ttlMin) {
    this.packageId = packageId;
    this.creationTime = Date.now();
    this.ttlMin = ttlMin;
    this.session_key = import_ed25519.Ed25519Keypair.generate();
    this.personalMessageSignature = "";
  }
  getPersonalMessage() {
    const message = `Requesting access to keys of package ${(0, import_bcs.toHex)(this.packageId)} for ${this.ttlMin} mins, session key ${(0, import_bcs.toBase64)(this.session_key.getPublicKey().toRawBytes())}, created at ${this.creationTime}`;
    return new TextEncoder().encode(message);
  }
  setPersonalMessageSignature(personalMessageSignature) {
    this.personalMessageSignature = personalMessageSignature;
  }
  getCertificate() {
    if (this.personalMessageSignature === "") {
      throw new Error("Personal message signature is not set");
    }
    return {
      session_vk: (0, import_bcs.toBase64)(this.session_key.getPublicKey().toRawBytes()),
      creation_time: this.creationTime,
      ttl_min: this.ttlMin,
      signature: this.personalMessageSignature
    };
  }
  async createRequestParams(txBytes) {
    let eg_sk = (0, import_elgamal.generateSecretKey)();
    const msgToSign = RequestFormat.serialize({
      ptb: txBytes.slice(1),
      enc_key: (0, import_elgamal.toPublicKey)(eg_sk),
      enc_verification_key: (0, import_elgamal.toVerificationKey)(eg_sk)
    }).toBytes();
    return {
      decryption_key: eg_sk,
      request_signature: (0, import_bcs.toBase64)(await this.session_key.sign(msgToSign))
    };
  }
}
//# sourceMappingURL=session-key.js.map
